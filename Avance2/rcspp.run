reset;
model rcsppRUN.mod;
data 5001n.dat;

option solver gurobi;

param Ttotal             default 0 ;
param TCPU1{objetivos}   default 0 ;
param MVF{objetivos}     default 0 ;
param PVF{objetivos}     default 0 ;
param f1{objetivos}      default 0 ;
param f2{objetivos}      default 0 ;

param TCPU2{ejecuciones} default 0 ;
param FN1{ejecuciones}   default 0 ;
param FN2{ejecuciones}   default 0 ;
param F1{ejecuciones}    default 0 ;
param F2{ejecuciones}    default 0 ;
param BT1{ejecuciones}   default 0 ;
param BT2{ejecuciones}   default 0 ;

# Variables para las métricas
param log_file symbolic;
let log_file := "frente_pareto.txt";
var dist_total;
var time_total;
var resource_total;

print "alpha,dist_total,time_total,resource_total,solve_time" > log_file;


############################################################################################
############################# Busqueda del mejor y peor valor ##############################
############################################################################################

for {gg in objetivos}{
  printf "  Objetivo ::::::: %s\n", gg ;
  let g := gg ;

  objective FO1 ;
  let Ttotal := time();
  solve ;
  let TCPU1[gg] := time() - Ttotal ;

  for {i in objetivos}{
    if F[i] < MV[i] then {
      let MV[i] := F[i] ;
    }
    if F[i] > PV[i] then {
      let PV[i] := F[i] ;
    }
  }
  for {i in objetivos}{
    let MVF[i] := MV[i] ;
    let PVF[i] := PV[i] ;
  }

  let f1[gg] := F[1] ;
  let f2[gg] := F[2] ;

  reset data x, arrival_time, F;
}

# Ajuste pequeño
for {i in objetivos}{
  let PV[i]  := PV[i] * 2  ;
  let PVF[i] := PV[i] ;
}

############################################################################################
############################ Busqueda de la frontera de pareto #############################
############################################################################################

for {gg in ejecuciones}{
	printf "==> Ejecucion ::::::: %s\n", gg ;

    for {i in objetivos}{
        let betha[i] := sigma[gg,i] ;
    }

    objective FO2 ;
    let Ttotal := time() ;
    solve ;
    let TCPU2[gg] := time() - Ttotal ;

    let FN1[gg] := if MV[1] != PV[1] then (F[1] - PV[1]) / (MV[1] - PV[1]) else 0 ;
	let FN2[gg] := if MV[2] != PV[2] then (F[2] - PV[2]) / (MV[2] - PV[2]) else 0 ;

    let F1[gg] := F[1] ;
    let F2[gg] := F[2] ;
    let BT1[gg] := sigma[gg,1] ;
    let BT2[gg] := sigma[gg,2] ;

    # Guardar ruta como archivo de texto
    
    let dist_total := sum{(i,j) in ARCS} dist[i,j] * x[i,j] * 1.0;
	let time_total := sum{(i,j) in ARCS} time_[i,j] * risk_multiplier[i,j] * x[i,j] * 1.0;
	let resource_total := sum{(i,j) in ARCS} resource[i,j] * x[i,j] * 1.0;

	display { (i,j) in ARCS : x[i,j] > 0.5 } > ("ruta_alpha_" & gg & ".txt");
	display { (i,j) in ARCS : x[i,j] > 0.5 } > archivoRuta;

	# Agregar métricas al log
	printf "%.4g,%.4g,%.4g,%.4g,%.4g\n", sigma[gg,1], dist_total, time_total, resource_total, TCPU2[gg] >> log_file;


    reset data x, arrival_time, F;
}


############################################################################################
################################ Resultados por instancia ##################################
############################################################################################

printf "\n\n" ;
display MVF, PVF, TCPU1, f1, f2 ;
display FN1, FN2, F1, F2, TCPU2 ;
